package models;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.persistence.Entity;
import javax.persistence.ManyToMany;
import javax.persistence.OneToOne;
import javax.validation.constraints.NotNull;

/**
 * Demonstrate the following relationships in the Ebean ORM:
 * <pre>{@code
 * 1 TO 0 - 1 RELATIONSHIP
 *
 * Each dorm floor has 0 - 1 dorm lounges
 * Each dorm lounge has exactly 1 dorm floor
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | DormFloor                       |||---|O| DormLounge                      |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToOne(mappedBy = "dormFloor")         @OneToOne(optional = false)
 * public DormLounge dormLounge;             public DormFloor dormFloor;
 * }</pre>
 * The absence of {@code mappedBy} marks this side of the <!--               -->
 * {@code @OneToOne}/{@code @OneToOne} relationship as the owning side; it is
 * analogous to {@code @ManyToOne}, the "one" side of a <!--                 -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship, only with the cardinality
 * of the "many" side limited to one. The other side of this relationship (the
 * one with {@code mappedBy}) is the inverse (non-owning) side.
 * <p>
 * In order to support this relationship, a column <em>is</em> added to the
 * database table that represents this Java class, with a uniqueness constraint
 * to limit the cardinality to one, as shown below; no column is added to the
 * table representing the other side of the relationship. The presence of {@code
 * optional = false} adds a {@code NOT NULL} constraint to the new column,
 * making it impossible to insert a row representing a dorm lounge that does not
 * have a dorm floor.
 * <pre>{@code
 * 0 - N TO 0 - M RELATIONSHIP
 *
 * Each study group has 0 - N students
 * Each student has 0 - M study groups
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | DormLounge                      |>O---O<| StudyGroup                      |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 * @ManyToMany                               @ManyToMany(mappedBy
 * public List<StudyGroup>                           = "studyGroups")
 *         studyGroups;                      public List<DormLounge>
 *                                                   dormLounges;
 * }</pre>
 * The absence of {@code mappedBy} marks this side of the <!--               -->
 * {@code @ManyToMany}/{@code @ManyToMany} relationship as the owning side. The
 * other side of this relationship (the one with {@code mappedBy}) is the
 * inverse (non-owning) side.
 * <p>
 * In order to support this relationship, no columns are added to the two
 * database tables that represent its Java classes; instead, an auxiliary join
 * table named {@code dorm_lounge_study_group} is added to the database, as
 * shown below.
 * <pre>{@code
 * 0 - 1 TO 0 - 1 RELATIONSHIP
 *
 * Each dorm lounge has 0 - 1 televisions
 * Each television has 0 - 1 dorm lounges (a TV might not be in a lounge)
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | DormLounge                      |O|---|O| Television                      |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToOne(mappedBy = "dormLounge")        @OneToOne
 * public Television television;             public DormLounge dormLounge;
 * }</pre>
 * The presence of {@code mappedBy} marks this side of the <!--              -->
 * {@code @OneToOne}/{@code @OneToOne} relationship as the inverse (non-owning)
 * side; it is analogous to {@code @OneToMany}, the "many" side of a <!--    -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship, only with its cardinality
 * limited to one. The other side of this relationship (the one without {@code
 * mappedBy}) is the owning side.
 * <p>
 * In order to support this relationship, a column <em>is not</em> added to the
 * database table that represents this Java class, as shown below; instead, a
 * column is added to the table representing the other side of the
 * relationship.
 * <p>
 * Here are the MySQL database table and the auxiliary join tables generated by
 * the Ebean ORM; the first column in each join table belongs to the owning side
 * of the relationship and the second column belongs to the inverse (non-owning)
 * side:
 * <pre>{@code
 * mysql> DESCRIBE dorm_lounge;
 * +---------------+--------------+------+-----+---------+----------------+
 * | Field         | Type         | Null | Key | Default | Extra          |
 * +---------------+--------------+------+-----+---------+----------------+
 * | id            | int(11)      | NO   | PRI | NULL    | auto_increment |
 * | name          | varchar(255) | NO   |     | NULL    |                |
 * | dorm_floor_id | int(11)      | NO   | UNI | NULL    |                |
 * +---------------+--------------+------+-----+---------+----------------+
 * 3 rows in set (0.00 sec)
 *
 * mysql> DESCRIBE dorm_lounge_study_group;
 * +----------------+---------+------+-----+---------+-------+
 * | Field          | Type    | Null | Key | Default | Extra |
 * +----------------+---------+------+-----+---------+-------+
 * | dorm_lounge_id | int(11) | NO   | PRI | NULL    |       |
 * | study_group_id | int(11) | NO   | PRI | NULL    |       |
 * +----------------+---------+------+-----+---------+-------+
 * 2 rows in set (0.00 sec)
 *
 * }</pre>
 */
@Entity
@SuppressWarnings({"WeakerAccess", "CanBeFinal", "unused"})
public class DormLounge extends DemoModel {

    @OneToOne(optional = false)
    public DormFloor dormFloor;

    @ManyToMany
    public List<StudyGroup> studyGroups;

    @OneToOne(mappedBy = "dormLounge")
    public Television television;

    public DormLounge(@NotNull String name, @NotNull DormFloor dormFloor,
            @NotNull List<StudyGroup> studyGroups) {
        super(name);
        this.dormFloor = dormFloor;
        this.studyGroups = studyGroups;
        this.save();
        this.dormFloor.refresh();

        for (StudyGroup studyGroup : this.studyGroups) {
            studyGroup.refresh();
        }
    }

    @Override
    @NotNull
    public String getObjectDescription() {
        return getObjectDescriptionFromStrings(Arrays.asList(
                DemoModel.objectToString(DormFloor.class, dormFloor),
                DemoModel.objectsToString(StudyGroup.class, studyGroups),
                DemoModel.objectToString(Television.class, television)));
    }

    @Override
    @NotNull
    public String getRelatedObjectsDescription() {
        return getRelatedObjectsDescriptionFromStrings(Stream.concat(
                Stream.of(dormFloor.getObjectDescription()),
                studyGroups.stream().map(StudyGroup::getObjectDescription))
                .collect(Collectors.toList()));
    }

}
