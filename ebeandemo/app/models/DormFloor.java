package models;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import javax.persistence.Entity;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.validation.constraints.NotNull;

/**
 * Demonstrate the following relationships in the Ebean ORM:
 * <pre>{@code
 * 1 TO 0 - N RELATIONSHIP
 *
 * Each dorm has 0 - N dorm floors (see note below)
 * Each dorm floor has exactly 1 dorm
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | Dorm                            |||---O<| DormFloor                       |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToMany(mappedBy = "dorm")             @ManyToOne(optional = false)
 * public List<DormFloor> dormFloors;        public Dorm dorm;
 * }</pre>
 * <strong>Note:</strong> It seems more logical to say that each dorm has 1 - N
 * dorm floors, but the Ebean ORM does not support this type of relationship;
 * see the file {@code README.md} in the root directory of this project for
 * further discussion of the standard relationships that cannot be modeled.
 * <p>
 * The absence of {@code mappedBy} marks this side of the <!--               -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship as the owning side. The
 * other side of this relationship (the one with {@code mappedBy}) is the
 * inverse (non-owning) side.
 * <p>
 * In order to support this relationship, a column <em>is</em> added to the
 * database table that represents this Java class, as shown below; no column is
 * added to the table representing the other side of the relationship. The
 * presence of {@code optional = false} adds a {@code NOT NULL} constraint to
 * the new column, making it impossible to insert a row representing a dorm
 * floor that does not have a dorm.
 * <pre>{@code
 * 1 TO 0 - 1 RELATIONSHIP
 *
 * Each dorm floor has 0 - 1 dorm lounges
 * Each dorm lounge has exactly 1 dorm floor
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | DormFloor                       |||---|O| DormLounge                      |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToOne(mappedBy = "dormFloor")         @OneToOne(optional = false)
 * public DormLounge dormLounge;             public DormFloor dormFloor;
 * }</pre>
 * The presence of {@code mappedBy} marks this side of the <!--              -->
 * {@code @OneToOne}/{@code @OneToOne} relationship as the inverse (non-owning)
 * side; it is analogous to {@code @OneToMany}, the "many" side of a <!--    -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship, only with its cardinality
 * limited to one. The other side of this relationship (the one without {@code
 * mappedBy}) is the owning side.
 * <p>
 * In order to support this relationship, a column <em>is not</em> added to the
 * database table that represents this Java class, as shown below; instead, a
 * column is added to the table representing the other side of the
 * relationship.
 * <pre>{@code
 * 1 TO 0 - N RELATIONSHIP
 *
 * Each dorm floor has 0 - N dorm rooms (a floor might have no assignable rooms)
 * Each dorm room has exactly 1 dorm floor
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | DormFloor                       |||---O<| DormRoom                        |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToMany(mappedBy = "dormFloor")        @ManyToOne(optional = false)
 * public List<DormRoom> dormRooms;          public DormFloor dormFloor;
 * }</pre>
 * The presence of {@code mappedBy} marks this side of the <!--              -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship as the inverse
 * (non-owning) side. The other side of this relationship (the one without
 * {@code mappedBy}) is the owning side.
 * <p>
 * In order to support this relationship, a column <em>is not</em> added to the
 * database table that represents this Java class, as shown below; instead, a
 * column is added to the table representing the other side of the relation.
 * <p>
 * Here is the MySQL database table generated by the Ebean ORM:
 * <pre>{@code
 * mysql> DESCRIBE dorm_floor;
 * +---------+--------------+------+-----+---------+----------------+
 * | Field   | Type         | Null | Key | Default | Extra          |
 * +---------+--------------+------+-----+---------+----------------+
 * | id      | int(11)      | NO   | PRI | NULL    | auto_increment |
 * | name    | varchar(255) | NO   |     | NULL    |                |
 * | dorm_id | int(11)      | NO   | MUL | NULL    |                |
 * +---------+--------------+------+-----+---------+----------------+
 * 3 rows in set (0.00 sec)
 *
 * }</pre>
 */
@Entity
@SuppressWarnings({"WeakerAccess", "CanBeFinal", "unused"})
public class DormFloor extends DemoModel {

    @ManyToOne(optional = false)
    public Dorm dorm;

    @OneToOne(mappedBy = "dormFloor")
    public DormLounge dormLounge;

    @OneToMany(mappedBy = "dormFloor")
    public List<DormRoom> dormRooms;

    public DormFloor(@NotNull String name, @NotNull Dorm dorm) {
        super(name);
        this.dorm = dorm;
        this.save();
        this.dorm.refresh();
    }

    @Override
    @NotNull
    public String getObjectDescription() {
        return getObjectDescriptionFromStrings(Arrays.asList(
                DemoModel.objectToString(Dorm.class, dorm),
                DemoModel.objectToString(DormLounge.class, dormLounge),
                DemoModel.objectsToString(DormRoom.class, dormRooms)));
    }

    @Override
    @NotNull
    public String getRelatedObjectsDescription() {
        return getRelatedObjectsDescriptionFromStrings(
                Collections.singletonList(dorm.getObjectDescription()));
    }

}
