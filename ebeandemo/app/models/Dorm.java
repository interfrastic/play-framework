package models;

import java.util.List;
import java.util.stream.Collectors;
import javax.persistence.Entity;
import javax.persistence.OneToMany;

/**
 * Demonstrate the following relationships in the Ebean ORM:
 * <pre>{@code
 * Each dorm has 1 - N dorm floors
 * Each dorm floor has exactly 1 dorm
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | Dorm                            |||---|<| DormFloor                       |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToMany(mappedBy = "dorm")             @ManyToOne
 *     optional = false)  // ERROR!          public Dorm dorm;
 * public List<DormFloor> dormFloors;
 * }</pre>
 * It is currently impossible to implement the relationship above in the Ebean
 * ORM because {@code @oneToMany} does not support {@code optional = false}.
 * <p>
 * This is the actual implementation, which technically allows a dorm with no
 * floors:
 * <pre>{@code
 * Each dorm has 0 - N dorm floors
 * Each dorm floor has exactly 1 dorm
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | Dorm                            |||---O<| DormFloor                       |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToMany(mappedBy = "dorm")             @ManyToOne
 * public List<DormFloor> dormFloors;        public Dorm dorm;
 * }</pre>
 * The presence of {@code mappedBy} marks this side of the <!--              -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship as the inverse
 * (non-owning) side. The other side of this relationship (the one without
 * {@code mappedBy}) is the owning side.
 * <p>
 * In order to support this relationship, a column <em>is not</em> added to the
 * database table that represents this Java class, as shown below; instead, a
 * column is added to the table representing the other side of the relation.
 * <p>
 * Here is the MySQL database table generated by the Ebean ORM:
 * <pre>{@code
 * mysql> DESCRIBE dorm;
 * +-------+--------------+------+-----+---------+----------------+
 * | Field | Type         | Null | Key | Default | Extra          |
 * +-------+--------------+------+-----+---------+----------------+
 * | id    | int(11)      | NO   | PRI | NULL    | auto_increment |
 * | name  | varchar(255) | YES  |     | NULL    |                |
 * +-------+--------------+------+-----+---------+----------------+
 * 2 rows in set (0.00 sec)
 *
 * }</pre>
 */
@Entity
@SuppressWarnings({"WeakerAccess", "CanBeFinal", "unused"})
public class Dorm extends CollegeModel {

    @OneToMany(mappedBy = "dorm")
    public List<DormFloor> dormFloors;

    public Dorm(String name) {
        super(name);
        this.save();
    }

    public String getDescription() {
        StringBuilder sb = new StringBuilder(this.toString());

        sb.append(" has ");

        if (dormFloors.size() > 0) {
            sb.append(dormFloors.stream().map(Object::toString)
                    .collect(Collectors.joining(", ")));
        } else {
            sb.append("no ").append(DormFloor.class.getSimpleName())
                    .append(" objects");
        }

        return sb.toString();
    }

}
