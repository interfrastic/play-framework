package models;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.persistence.Entity;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import javax.validation.constraints.NotNull;

/**
 * Demonstrate the following relationships in the Ebean ORM:
 * <pre>{@code
 * Each dorm room has 0 - N students
 * Each student has 0 - 1 dorm rooms (students may live off campus)
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | DormRoom                        |O|---O<| Student                         |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToMany(mappedBy = "dormRoom")         @ManyToOne
 * public List<Student> students;            public DormRoom dormRoom;
 * }</pre>
 * The absence of {@code mappedBy} marks this side of the <!--               -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship as the owning side. The
 * other side of this relationship (the one without {@code mappedBy}) is the
 * inverse (non-owning) side.
 * <p>
 * In order to support this relationship, a column <em>is</em> added to the
 * database table that represents this Java class, as shown below; no column is
 * added to the table representing the other side of the relationship.
 * <pre>{@code
 * Each parking space has 0 - 1 students
 * Each student has 0 - 1 parking spaces (limit 1 space per student)
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | ParkingSpace                    |O|---|O| Student                         |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @OneToOne(mappedBy                        @OneToOne
 *         = "parkingSpace")                 public ParkingSpace parkingSpace;
 * public Student student;
 * }</pre>
 * The absence of {@code mappedBy} marks this side of the <!--               -->
 * {@code @OneToOne}/{@code @OneToOne} relationship as the owning side; it is
 * analogous to {@code @ManyToOne}, the "one" side of a <!--                 -->
 * {@code @OneToMany}/{@code @ManyToOne} relationship, only with the cardinality
 * of the "many" side limited to one. The other side of this relationship (the
 * one with {@code mappedBy}) is the inverse (non-owning) side.
 * <p>
 * In order to support this relationship, a column <em>is</em> added to the
 * database table that represents this Java class, with a uniqueness constraint
 * to limit the cardinality to one, as shown below; no column is added to the
 * table representing the other side of the relationship.
 * <pre>{@code
 * Each scholarship has 0 - N students
 * Each student has 0 - N scholarships
 *
 * +---------------------------------+       +---------------------------------+
 * |                                 |       |                                 |
 * | Scholarship                     |>O---O<| Student                         |
 * |                                 |       |                                 |
 * +---------------------------------+       +---------------------------------+
 *
 * @ManyToMany(mappedBy                      @ManyToMany
 *         = "scholarships")                 public List<Scholarship>
 * public List<Student> students;                     scholarships;
 * }</pre>
 * <p>
 * The absence of {@code mappedBy} marks this side of the <!--               -->
 * {@code @ManyToMany}/{@code @ManyToMany} relationship as the owning side. The
 * other side of this relationship (the one with {@code mappedBy}) is the
 * inverse (non-owning) side.
 * <p>
 * In order to support this relationship, no columns are added to the two
 * database tables that represent its Java classes; instead, an auxiliary join
 * table named {@code student_scholarship} is added to the database, as shown
 * below.
 * <p>
 * Here are the MySQL database table and the auxiliary join tables generated by
 * the Ebean ORM; the first column in each join table belongs to the owning side
 * of the relationship and the second column belongs to the inverse (non-owning)
 * side:
 * <pre>{@code
 * mysql> DESCRIBE student;
 * +------------------+--------------+------+-----+---------+----------------+
 * | Field            | Type         | Null | Key | Default | Extra          |
 * +------------------+--------------+------+-----+---------+----------------+
 * | id               | int(11)      | NO   | PRI | NULL    | auto_increment |
 * | name             | varchar(255) | YES  |     | NULL    |                |
 * | dorm_room_id     | int(11)      | YES  | MUL | NULL    |                |
 * | parking_space_id | int(11)      | YES  | UNI | NULL    |                |
 * +------------------+--------------+------+-----+---------+----------------+
 * 4 rows in set (0.00 sec)
 *
 * mysql> DESCRIBE student_scholarship;
 * +----------------+---------+------+-----+---------+-------+
 * | Field          | Type    | Null | Key | Default | Extra |
 * +----------------+---------+------+-----+---------+-------+
 * | student_id     | int(11) | NO   | PRI | NULL    |       |
 * | scholarship_id | int(11) | NO   | PRI | NULL    |       |
 * +----------------+---------+------+-----+---------+-------+
 * 2 rows in set (0.00 sec)
 *
 * }</pre>
 */
@Entity
@SuppressWarnings({"WeakerAccess", "CanBeFinal", "unused"})
public class Student extends CollegeModel {

    @ManyToOne // Default: optional = true.
    public DormRoom dormRoom;

    @OneToOne // Default: optional = true.
    public ParkingSpace parkingSpace;

    @ManyToMany
    public List<Scholarship> scholarships;

    public Student(String name, DormRoom dormRoom, ParkingSpace parkingSpace,
            @NotNull List<Scholarship> scholarships) {
        super(name);
        this.dormRoom = dormRoom;
        this.parkingSpace = parkingSpace;
        this.scholarships = scholarships;
        this.save();

        if (this.dormRoom != null) {
            this.dormRoom.refresh();
        }

        if (this.parkingSpace != null) {
            this.parkingSpace.refresh();
        }

        for (Scholarship scholarship : this.scholarships) {
            scholarship.refresh();
        }
    }

    public String getDescription() {
        StringBuilder sb = new StringBuilder(this.toString());

        sb.append(" has ");

        if (dormRoom == null) {
            sb.append("no ").append(DormRoom.class.getSimpleName())
                    .append(" object");
        } else {
            sb.append(dormRoom);
        }

        sb.append(", ");

        if (parkingSpace == null) {
            sb.append("no ").append(ParkingSpace.class.getSimpleName())
                    .append(" object");
        } else {
            sb.append(parkingSpace);
        }

        sb.append(", ");

        if (scholarships.isEmpty()) {
            sb.append("no ").append(ParkingSpace.class.getSimpleName())
                    .append(" objects");
        } else {
            sb.append(scholarships.stream().map(Objects::toString).collect(
                    Collectors.joining(", ")));
        }

        return sb.toString();
    }

}
